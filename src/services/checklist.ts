import type {
  AnalysisResult,
  ChecklistItem,
  ChecklistState,
  ChecklistItemState,
} from "../schemas/analysis-result.js";

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Constants & Regexes
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** HTML comment marker used to identify bot comments (invisible on GitHub). */
export const BOT_MARKER = "<!-- deploy-checklist-bot:v1 -->";

/** Extracts commit SHA from <!-- sha:abc123 --> metadata. */
const SHA_REGEX = /<!-- sha:(\w+) -->/;

/**
 * Parses a checklist line like: - [x] **Description** ðŸ”´ â€” Reasoning\n  _Rule: rule-id_
 * Captures: [1] checked state (" " or "x"), [2] description, [3] reasoning, [4] rule ID
 * Global flag (/g) lets us use exec() in a while loop to extract all items.
 */
const ITEM_REGEX =
  /- \[([ x])\] \*\*(.+?)\*\*(?:\s*[^\nâ€”]*)â€” (.+?)\n\s+_Rule: (.+?)_/g;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Public API
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Generate a markdown checklist comment from analysis results. */
export function generateChecklist(
  result: AnalysisResult,
  sha: string
): string {
  // Build markdown: BOT_MARKER lets us find this comment later, sha tracks which commit was analyzed
  const lines: string[] = [
    "## Deploy Checklist",
    "",
    BOT_MARKER,
    `<!-- sha:${sha} -->`,
    "",
    "The following items were identified for this PR. Check each item to confirm",
    "it has been addressed before merging.",
    "",
  ];

  if (result.summary) {
    lines.push(`> ${result.summary}`, "");
  }

  // Sort by priority: high â†’ medium â†’ low
  const priorityOrder = { high: 0, medium: 1, low: 2 };
  const sorted = [...result.items].sort(
    (a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]
  );

  for (const item of sorted) {
    const priorityBadge =
      item.priority === "high" ? " ðŸ”´" : item.priority === "medium" ? " ðŸŸ¡" : "";
    lines.push(
      `- [ ] **${item.description}**${priorityBadge} â€” ${item.reasoning}`,
      `  _Rule: ${item.rule_id}_`,
      ""
    );
  }

  lines.push(
    "---",
    "_Generated by Deploy Checklist Bot | Re-analyze: push a new commit_"
  );

  return lines.join("\n");
}

/** Parse an existing bot comment into ChecklistState. Returns null if not a bot comment. */
export function parseChecklist(commentBody: string): ChecklistState | null {
  if (!commentBody.includes(BOT_MARKER)) {
    return null;
  }

  const shaMatch = commentBody.match(SHA_REGEX);
  const sha = shaMatch ? shaMatch[1] : "unknown";

  const items: ChecklistItemState[] = [];
  let match: RegExpExecArray | null;

  // Global regex retains lastIndex between calls â€” reset to avoid skipping matches
  ITEM_REGEX.lastIndex = 0;

  // exec() with /g returns one match per call, advancing lastIndex each time
  while ((match = ITEM_REGEX.exec(commentBody)) !== null) {
    const [, checkedChar, description, reasoning, ruleId] = match;

    items.push({
      checked: checkedChar === "x",
      item: {
        rule_id: ruleId,
        check: "",  // Not recoverable from markdown â€” only stored in analysis results
        description,
        reasoning,
        priority: "medium",  // Priority badge is visual only â€” default to medium when parsing back
      },
    });
  }

  return {
    sha,
    items,
    allComplete: items.length > 0 && items.every((i) => i.checked),
  };
}

/**
 * Merge old checklist state with new analysis results.
 * Preserves check state for items with matching rule_id + description.
 */
export function mergeChecklist(
  oldState: ChecklistState,
  newResult: AnalysisResult,
  newSha: string
): string {
  // Build lookup: "rule_id:description" â†’ was_checked.
  // Using composite key so items match even if reasoning or priority changed.
  const oldItemMap = new Map<string, boolean>();
  for (const item of oldState.items) {
    const key = `${item.item.rule_id}:${item.item.description}`;
    oldItemMap.set(key, item.checked);
  }

  const lines: string[] = [
    "## Deploy Checklist",
    "",
    BOT_MARKER,
    `<!-- sha:${newSha} -->`,
    "",
    "The following items were identified for this PR. Check each item to confirm",
    "it has been addressed before merging.",
    "",
  ];

  if (newResult.summary) {
    lines.push(`> ${newResult.summary}`, "");
  }

  const priorityOrder = { high: 0, medium: 1, low: 2 };
  const sorted = [...newResult.items].sort(
    (a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]
  );

  for (const item of sorted) {
    const key = `${item.rule_id}:${item.description}`;
    const wasChecked = oldItemMap.get(key) ?? false;
    const checkbox = wasChecked ? "x" : " ";

    const priorityBadge =
      item.priority === "high" ? " ðŸ”´" : item.priority === "medium" ? " ðŸŸ¡" : "";
    lines.push(
      `- [${checkbox}] **${item.description}**${priorityBadge} â€” ${item.reasoning}`,
      `  _Rule: ${item.rule_id}_`,
      ""
    );
  }

  lines.push(
    "---",
    "_Generated by Deploy Checklist Bot | Re-analyze: push a new commit_"
  );

  return lines.join("\n");
}

/**
 * Check if all items in a checklist comment are checked off.
 * Returns true for non-bot comments or comments with no items (nothing to block on).
 */
export function isComplete(commentBody: string): boolean {
  const state = parseChecklist(commentBody);
  if (!state || state.items.length === 0) return true;
  return state.allComplete;
}
